package main

import (
	"fmt"
	"os"
	"slices"
	"strconv"
	"strings"

	"github.com/DanielGekeler/emojitoolkit/internal"
)

func main() {
	xml := internal.LoadXML("ucd.nounihan.flat.xml")

	builder := new(strings.Builder)
	builder.WriteString("// Code generated by generator/main.go DO NOT EDIT.\n\n")
	builder.WriteString("package emojitoolkit\n\n")

	repertoire := xml.GetFirstChild("repertoire")
	builder.WriteString("var emoji_ranges1 = " + GenerateEmojiRanges(repertoire) + "\n")
	builder.WriteString("var emoji_ranges2 = " + GenerateEmojiRanges2(repertoire) + "\n")
	builder.WriteString("var emoji_ranges3 = " + GenerateEmojiRanges3(repertoire) + "\n")

	variants := xml.GetFirstChild("standardized-variants")
	builder.WriteString("var variant_ranges = " + GenerateVariantRanges(variants) + "\n")

	os.WriteFile("generated_data.go", []byte(builder.String()), os.ModePerm)
}

// Singe Codepoint emojis with Emoji_Presentation=Yes & Emoji_Component=No
func GenerateEmojiRanges(repertoire internal.AnyXML) string {
	codepoints := make([]int32, 0, 1024)

	for _, char := range repertoire.Children {
		if char.GetAttr("EPres") == "Y" && char.GetAttr("EComp") == "N" {
			n, _ := strconv.ParseUint(char.GetAttr("cp"), 16, 32)
			codepoints = append(codepoints, int32(n))
		}
	}

	return writeRanges(codepoints)
}

// Emojis that appear as text by default but can appear with an emoji presentation.
// These characters will appear as emojis when followed by U+FE0F (Variation Selector-16)
//
// ED-7 see https://www.unicode.org/reports/tr51/#def_text_presentation
func GenerateEmojiRanges2(repertoire internal.AnyXML) string {
	codepoints := make([]int32, 0, 1024)

	for _, char := range repertoire.Children {
		if char.GetAttr("Emoji") == "Y" && char.GetAttr("EPres") == "N" {
			n, _ := strconv.ParseUint(char.GetAttr("cp"), 16, 32)
			codepoints = append(codepoints, int32(n))
		}
	}

	return writeRanges(codepoints)
}

// Emojis that can be used in a RGI_Emoji_Modifier_Sequence
//
// ED-22 see https://www.unicode.org/reports/tr51/#def_std_emoji_modifier_sequence_set
func GenerateEmojiRanges3(repertoire internal.AnyXML) string {
	codepoints := make([]int32, 0, 1024)

	for _, char := range repertoire.Children {
		if char.GetAttr("EBase") == "Y" {
			n, _ := strconv.ParseUint(char.GetAttr("cp"), 16, 32)
			if n != 0x1F46A {
				// Skip U+1F46A Family
				codepoints = append(codepoints, int32(n))
			}
		}
	}

	return writeRanges(codepoints)
}

func GenerateVariantRanges(variants internal.AnyXML) string {
	text_variants := make([]int32, 0, 256)
	emoji_variants := make([]int32, 0, 256)
	for _, variant := range variants.Children {
		desc := variant.GetAttr("desc")
		cps := variant.GetAttr("cps")
		codepoint, _ := strconv.ParseInt(strings.SplitN(cps, " ", 2)[0], 16, 32)

		if desc == "text style" {
			text_variants = append(text_variants, int32(codepoint))
		} else if desc == "emoji style" {
			emoji_variants = append(emoji_variants, int32(codepoint))
		}
	}

	slices.Sort(text_variants)
	slices.Sort(emoji_variants)

	// These are currently equal allowing for optimization but this may change in the future
	if !slices.Equal(text_variants, emoji_variants) {
		panic("text_variants and emoji_variants are not equal")
	}

	return writeRanges(emoji_variants)
}

func writeRanges(codepoints []int32) string {
	ranges := make([]int32, 0)
	current_range := make([]int32, 0)
	for _, v := range codepoints {
		if len(current_range) == 0 {
			current_range = append(current_range, v)
			continue
		}

		if current_range[len(current_range)-1]+1 == v {
			current_range = append(current_range, v)
		} else {
			ranges = append(ranges, current_range[0], current_range[len(current_range)-1])
			current_range = []int32{v}
		}
	}
	ranges = append(ranges, current_range[0], current_range[len(current_range)-1])

	return fmt.Sprintf("%#v", ranges)
}
